package flink_apps
import org.apache.flink.api.java.aggregation.Aggregations
import org.apache.flink.api.java.utils.ParameterTool
import org.apache.flink.api.scala.DataSet
import org.apache.flink.streaming.api.scala._


object FlinkApps {

  /**
   * Generates a dataset tuple with each string passed by the DataSet[String] and its count
   * @param genDatasetSample
   * @return
   */
  def wordCount(genDatasetSample : DataSet[String]) (): Seq[(String, Int)] = {
    val counts  = genDatasetSample.flatMap { _.toLowerCase.split("\\W+") filter { _.nonEmpty } }
      .map { (_, 1) }
      .groupBy(0)
      .sum(1)

    counts.collect()
  }



  /**
   * This program implements a modified version of the TPC-H query 10.
   *
   * The original query can be found at
   * [http://www.tpc.org/tpch/spec/tpch2.16.0.pdf](http://www.tpc.org/tpch/spec/tpch2.16.0.pdf)
   * (page 45).
   *
   * This program implements the following SQL equivalent:
   *
   * {{{
   * SELECT
   *        c_custkey,
   *        c_name,
   *        c_address,
   *        n_name,
   *        c_acctbal
   *        SUM(l_extendedprice * (1 - l_discount)) AS revenue,
   * FROM
   *        customer,
   *        orders,
   *        lineitem,
   *        nation
   * WHERE
   *        c_custkey = o_custkey
   *        AND l_orderkey = o_orderkey
   *        AND YEAR(o_orderdate) > '1990'
   *        AND l_returnflag = 'R'
   *        AND c_nationkey = n_nationkey
   * GROUP BY
   *        c_custkey,
   *        c_name,
   *        c_acctbal,
   *        n_name,
   *        c_address
   * }}}
   *
   * Compared to the original TPC-H query this version does not print
   * c_phone and c_comment, only filters by years greater than 1990 instead of
   * a period of 3 months, and does not sort the result by revenue..
   *
   * Input files are plain text CSV files using the pipe character ('|') as field separator
   * as generated by the TPC-H data generator which is available at
   * [http://www.tpc.org/tpch/](a href="http://www.tpc.org/tpch/).
   */

  def TPCHQuery10 (customers:  DataSet[(Int, String, String, Int, Double)], orders: DataSet[(Int, Int, String)], lineItem: DataSet[(Int, Double, Double, String)], nation: DataSet[(Int, String)]) {

    val params: ParameterTool = ParameterTool.fromArgs(args)
    if (!params.has("lineitem") && !params.has("customer") &&
      !params.has("orders") && !params.has("nation")) {
      println("  This program expects data from the TPC-H benchmark as input data.")
      println("  Due to legal restrictions, we can not ship generated data.")
      println("  You can find the TPC-H data generator at http://www.tpc.org/tpch/.")
      println("  Usage: TPCHQuery10" +
        "--customer <path> --orders <path> --lineitem <path> --nation <path> --output <path>")
      return
    }

    // get customer data set: (custkey, name, address, nationkey, acctbal)
    val customers = getCustomerDataSet(env, params.get("customer"))
    // get orders data set: (orderkey, custkey, orderdate)
    val orders = getOrdersDataSet(env, params.get("orders"))
    // get lineitem data set: (orderkey, extendedprice, discount, returnflag)
    val lineitems = getLineitemDataSet(env, params.get("lineitem"))
    // get nation data set: (nationkey, name)
    val nations = getNationDataSet(env, params.get("nation"))

    // filter orders by years
    val orders1990 = orders.filter( o => o._3.substring(0,4).toInt > 1990)
      .map( o => (o._1, o._2))

    // filter lineitems by return status
    val lineitemsReturn = lineitems.filter( l => l._4.equals("R"))
      .map( l => (l._1, l._2 * (1 - l._3)) )

    // compute revenue by customer
    val revenueByCustomer = orders1990.joinWithHuge(lineitemsReturn).where(0).equalTo(0)
      .apply( (o,l) => (o._2, l._2) )
      .groupBy(0)
      .aggregate(Aggregations.SUM, 1)

    // compute final result by joining customer and nation information with revenue
    val result = customers.joinWithTiny(nations).where(3).equalTo(0)
      .apply( (c, n) => (c._1, c._2, c._3, n._2, c._5) )
      .join(revenueByCustomer).where(0).equalTo(0)
      .apply( (c, r) => (c._1, c._2, c._3, c._4, c._5, r._2) )

    println("Printing result to stdout")
    result.print()
    }


    def getCustomerDataSet(env: ExecutionEnvironment, customerPath: String):
    DataSet[(Int, String, String, Int, Double)] = {
      env.readCsvFile[(Int, String, String, Int, Double)](
        customerPath,
        fieldDelimiter = "|",
        includedFields = Array(0,1,2,3,5) )
    }

    def getOrdersDataSet(env: ExecutionEnvironment, ordersPath: String):
    DataSet[(Int, Int, String)] = {
      env.readCsvFile[(Int, Int, String)](
        ordersPath,
        fieldDelimiter = "|",
        includedFields = Array(0, 1, 4) )
    }

    def getLineitemDataSet(env: ExecutionEnvironment, lineitemPath: String):
    DataSet[(Int, Double, Double, String)] = {
      env.readCsvFile[(Int, Double, Double, String)](
        lineitemPath,
        fieldDelimiter = "|",
        includedFields = Array(0, 5, 6, 8) )
    }

    def getNationDataSet(env: ExecutionEnvironment, nationPath: String):
    DataSet[(Int, String)] = {
      env.readCsvFile[(Int, String)](
        nationPath,
        fieldDelimiter = "|",
        includedFields = Array(0, 1) )
    }
  }

}




